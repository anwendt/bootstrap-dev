{{- if not .Values.externalClusterConfig }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: script-executor-config
  namespace: {{ .Values.clusterconfigNamespace }}
  annotations:
    argocd.argoproj.io/sync-wave: "-20"  
data:
  script-executor.sh: |
    #!/bin/bash 
    set -euo pipefail
    # Function to get the Cluster ID based on the cluster name
    getClusterId() {
        local CLUSTER_NAME="$1"

        # Check if the cluster name is provided
        if [ -z "$CLUSTER_NAME" ]; then
            echo "Please provide a cluster name."
            return 1
        fi

        # Retrieve the Cluster ID using kubectl
        local CLUSTER_ID
        CLUSTER_ID=$(kubectl get clusters.management.cattle.io -o json | jq -r --arg CLUSTER_NAME "$CLUSTER_NAME" '.items[] | select(.metadata.annotations["objectset.rio.cattle.io/owner-name"] == $CLUSTER_NAME) | .metadata.name')

        # Check if a Cluster ID was found
        if [ -z "$CLUSTER_ID" ]; then
            echo "Cluster with name '$CLUSTER_NAME' not found."
            return 2
        fi

        # Return the Cluster ID
        echo "$CLUSTER_ID"
    }

    # Function to get the systemDefaultRegistry setting from Rancher
    getSystemDefaultRegistry() {
        # Retrieve the systemDefaultRegistry from Rancher settings
        local SYSTEM_DEFAULT_REGISTRY
        SYSTEM_DEFAULT_REGISTRY=$(kubectl get settings.management.cattle.io system-default-registry -o json | jq -r '.value')

        # Check if a value was found
        if [ -z "$SYSTEM_DEFAULT_REGISTRY" ]; then
            echo "No systemDefaultRegistry configured or not found."
            return 1
        fi

        # Return the systemDefaultRegistry
        echo "$SYSTEM_DEFAULT_REGISTRY"
    }

    # Function to store data in a Kubernetes Secret
    storeInSecretMap() {
        local CLUSTER_NAME="$1"
        local TARGET_SECRET="$2"
        local NAMESPACE="$3"

        if [ -z "$CLUSTER_NAME" ] || [ -z "$TARGET_SECRET" ] || [ -z "$NAMESPACE" ]; then
            echo "Missing required arguments. Usage: storeInSecretMap <Cluster-Name> <Target-Secret> <Namespace>"
            return 1
        fi

        # Get the Cluster ID and systemDefaultRegistry
        local CLUSTER_ID
        local SYSTEM_DEFAULT_REGISTRY
        CLUSTER_ID=$(getClusterId "$CLUSTER_NAME")
        SYSTEM_DEFAULT_REGISTRY=$(getSystemDefaultRegistry)

        # Validate results
        if [ -z "$CLUSTER_ID" ]; then
            echo "Failed to retrieve Cluster ID for '$CLUSTER_NAME'."
            return 2
        fi
        if [ -z "$SYSTEM_DEFAULT_REGISTRY" ]; then
            echo "Failed to retrieve systemDefaultRegistry."
            return 3
        fi

        # Create or update the Kubernetes secret
        kubectl create secret generic "$TARGET_SECRET" \
            --from-literal=cluster_name="$CLUSTER_NAME" \
            --from-literal=rancher_cluster_id="$CLUSTER_ID" \
            --from-literal=system_default_registry="$SYSTEM_DEFAULT_REGISTRY" \
            --namespace "$NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -

        echo "Data stored in Secret '$TARGET_SECRET' in namespace '$NAMESPACE'."
    }

    # Main script logic
    # Validate environment variables
    if [ -z "${TARGET_SECRET:-}" ]; then
        echo "TARGET_SECRET environment variable is not set. Exiting."
        exit 1
    fi

    if [ -z "${CLUSTER_NAME:-}" ]; then
        echo "CLUSTER_NAME environment variable is not set. Exiting."
        exit 1
    fi

    NAMESPACE="${NAMESPACE:-default}"

    # Call the function to store data in the secret
    storeInSecretMap "$CLUSTER_NAME" "$TARGET_SECRET" "$NAMESPACE"
{{- end }}